import csv
import os

import numpy as np
import pandas as pd
from itertools import product

from sim import simulate as sim

#TODO add charger_density once supported in sim.py
#TODO include support for depot_chargers. Not sure the best way to scale this
# to the number of actual chargers that would be present at a depot.
def genScenarios(battery_cap_kwh,nondepot_charger_rate):
    '''Generates a list of tuples of scenarios
        args: all tuples of a start (inclusive), end (exclusive), and step 
        size values. i.e. battery_cap_kwh=(125,700,100) 
    '''
    #TODO include error handling
    bat_range = np.arange(*battery_cap_kwh)
    non_depot_range = np.arange(*nondepot_charger_rate)
    scen_opts = [bat_range,non_depot_range,]
    scens = list(product(*scen_opts))
    keys = range(len(scens))
    scens = dict(zip(keys, scens))
    return scens

#TODO move to np_financial or otherwise to implement PMT()
def genAnnualizedCosts(bat_range,non_depot_range,rate,years,bus_base_price,
                       bprice_kwh,cprice_bos=265,cprice_scaled=511,
                       bos_coeff=0.8,scaled_coeff=0.2
                      ):
  """Generates a vector of annualized prices for given ranges. Assumes costs scale
  linearly.

  Parameters 
  ----------
        bat_range -- np.array() of battery capacities (kWh)
  non_depot_range -- np.array() of non-depot charger power (kW)
             rate -- interest rate for PMT calculation
            years -- number of periods for PMT (years) 
   bus_base_price -- floor price of a bus without any battery capacity (currency)
       bprice_kwh -- Battery price per kWh, scales linearly
       cprice_bos -- Estimated "balance of system" EVSE price/kW, scales 
                     linearly. Default:$265/kW, see notes
    cprice_scaled -- Estimated EVSE price/kW, derived from average costs,
                     scales linearly. Default:$511/kW, see notes
        bos_coeff -- weight to give to BOS EVSE price. Default: 0.8, see notes.
     scaled_coeff -- weight to give to scaled avg EVSE price. Default: 0.2, 
                     see notes.
  Returns
  -------
  results : dict
    a dict of annualized costs
      annualized_base_bus : float
        The annualized cost of bus_base_price
      annualized_bat : float
        The annualized cost of bprice_kwh
      annualized_charger : float
        The annualized cost of the weighted average of cprice_bos and cprice_scaled

  NOTES
  -----
  This is derived from the work of M. McCall et al in https://doi.org/10.1088/1748-9326/ab560d
  """
  bat_pv            = bat_range * bprice_kwh
  charger_pv_bos    = non_depot_range * cprice_bos
  charger_pv_scaled = non_depot_range * cprice_scaled

  annualized_base_bus        = -np.pmt(rate,years,bus_base_price)
  annualized_bat             = -np.pmt(rate,years / 2,bat_pv) * 2# assumes a mid-life battery replacement.
  annualized_charge_bos      = -np.pmt(rate,years,charger_pv_bos)
  annualized_charge_scaled   = -np.pmt(rate,years,charger_pv_scaled)

  anl_charge_weighted = (annualized_base_bus * bos_coeff) + (annualized_charge_scaled * scaled_coeff) 
  results = {'annualized_base_bus':annualized_base_bus,
             'annualized_bat':dict(zip(bat_range,annualized_bat)),
             'annualized_charger':dict(zip(non_depot_range,anl_charge_weighted)),
            }
  return results

def main(parsed_gtfs_prefix,osm_data,depots_filename,output_dir,battery_cap_kwh,
         nondepot_charger_rate,parameter_override=None
        ):
  """Runs Dispatch simulator with the given scenarios, in series.

  Parameters
  ----------
  parsed_gtfs_prefix :  str
    location and prefix of the parsed files generated by `parse_gtfs.py`
  osm_data : str
    location of the OSM pbf file for the GTFS feed being simulated
  depots_filename : str
    location of a csv file of depots in the following format:
      lat : float
        latitude of depot
      lng : float
        longitude of depot
      name : str
        name of the depot
      max_buses : int
        bus capacity
      url : str
        hyperlink to source of depot details
  output_dir : str
    location
  battery_cap_kwh : list
    list of ints,start (inclusive), end (exclusive), and step size values for 
    generating battery capacity scenarios
  nondepot_charger_rate : list
    list of ints, start (inclusive), end (exclusive), and step size values for
    generating non-depot EVSE charger scenarios
  parameter_override : dict
    dict that overrides any Dispatch parameter defaults. See
    `sim.generateParams()` for details on possible inputs.

  Returns
  -------
  scenarios_results: dataframe
    a df of of summary results for each scenario run
  """
  scenarios = genScenarios(battery_cap_kwh, nondepot_charger_rate)
  b_caps, cpowers = list(zip(*scenarios.values()))
  #TODO, probably should move these options into params of main(), but is that
  #getting too long? Advise on best practice here.
  an_costs = genAnnualizedCosts(b_caps,cpowers,rate=0.07,years=14,
                                bus_base_price=500_000,bprice_kwh=100)
  params = {}
  #TODO Note that this will overwrite params passed to main()
  # It may be best to just move all this out of CLI and into params exclusively?
  if parameter_override is not None:
    params = parameter_override
  scen_costs = {}
  for key,val in scenarios.items():
    bat_cap = val[0]
    cpower = val[1]
    prefix = f'{bat_cap}kwh_{cpower}_kw'
    #set up scenario parameters
    params['battery_cap_kwh'] = bat_cap
    params['nondepot_charger_rate'] = cpower
    params['bus_cost'] = an_costs['annualized_base_bus']
    params['battery_cost_per_kwh'] = an_costs['annualized_bat'][bat_cap]
    params['nondepot_charger_cost'] = an_costs['annualized_charger'][cpower]

    results = sim(parsed_gtfs_prefix, 
                  osm_data,
                  depots_filename,
                  parameters=params)
    # parse results and write to file
    scen_costs[prefix] = {'battery_cap_kwh':bat_cap,
                          'nondepot_charger_rate':cpower,
                          'optimized_buses':results['opti_buses'],
                          'optimized_chargers':results['opti_chargers'],
                          'optimized_cost':results['opti_cost'],
                          'nc_buses':results['nc_buses'],
                          'nc_chargers':results['nc_chargers'],
                          'nc_cost':results['nc_cost'],
                          'ac_buses':results['ac_buses'],
                          'ac_chargers':results['ac_chargers'],
                          'ac_cost':results['ac_cost']
                         }
    #create output dir if needed, and write to file
    if not os.path.exists(output_dir):
      os.mkdir(output_dir)
    results['opti_trips'].to_csv(f'{output_dir}/{prefix}_trips.csv')

    depot_res_name = f'{output_dir}/{prefix}_depot_counts.csv'
    with open(depot_res_name,'w',newline='') as csvfile:
      fieldnames = ['depot','bus_count']
      writer = csv.DictWriter(csvfile,fieldnames=fieldnames)
      writer.writeheader()
      #TODO include nc and ac depots as well
      for key, val in results['opti_depot_counts'].items():
        writer.writerow({'depot': key, 'bus_count': val})
    #create DF of summary results and write to file
  scen_costs = pd.DataFrame(scen_costs).T
  scen_costs.to_csv(f'{output_dir}/scenarios_results.csv')

if __name__ == '__main__':
  main('../../data/parsed_utahtransportationauthority59',
       '../../data/osm_utahtransportationauthority59.osm.pbf',
       '../../data/depots_actransit.csv',
       '../../tmp',
       [220,661,200],
       [100,501,200])